
(defmacro! defun!
	   (fn* (name arg body)
		`(def! ,name (fn* ,arg ,body))))

(defmacro! defm!
	   (fn* (name arg body)
		`(defmacro! ,name (fn* ,arg ,body))))

(defun! not (a)
	(if a nil t))

(defun! load-file (f)
	(eval (read-string (str "(do " (slurp f) ")"))))

;(defun! list (& body) body)
(defun! list (& body) (copy-list body))

(defun! count (x)
	(if x
	  (+ 1 (count (cdr x)))
	  0))

(defun! copy-list (x)
	(if x
	  (if (not (consp x))
	    x
	    (cons (car x) (copy-list (cdr x))))
	  nil))

(defun! last (x)
	(if x
	  (if (consp x)
	    (if (cdr x)
	      (last (cdr x))
	      x))
	  nil))

;(defun! nth (x n)
;	(if (eq n 0)
;	  (car x)
;	  (nth (cdr x) (- n 1))))

(defm! concat (& body)
       (if (not body) nil
	 `(let* (concat_car (copy-list ,(car body)))
	   (do (if (consp concat_car)
		 (rplacd (last concat_car) (concat ,@(cdr body)))
		 (concat ,@(cdr body)))
	      concat_car))))

(defm! cond (& xs)
       (if (> (count xs) 0)
	 (list 'if (car xs)
	          (if (> (count xs) 1)
		    (nth xs 1)
		    (throw "odd number of forms to cond"))
		  (cons 'cond (cdr (cdr xs))))))

(defm! or (& xs)
       (if (not xs)
	 nil
	 (if (= 1 (count xs))
	   (car xs)
	   `(let* (or_FIXME ,(car xs))
	      (if or_FIXME or_FIXME
		(or ,@(cdr xs)))))))

