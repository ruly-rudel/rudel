
(defmacro! defun!
	   (fn* (name arg body)
		`(def! ,name (fn* ,arg ,body))))

(defmacro! defm!
	   (fn* (name arg body)
		`(defmacro! ,name (fn* ,arg ,body))))

(defun! not (a)
	(if a nil t))

(defun! load-file (f)
	(eval (read-string (str "(do " (slurp f) ")"))))

;(defun! list (& body) body)
(defun! list (& body) (copy-list body))

;(defun! count (x)
;	(if x
;	  (if (consp x) (+ 1 (count (cdr x))))))

(defun! count (x)
	(if (seqnilp x) 0
	  (if (seqp x) (+ 1 (count (cdr x)))
	    0)))

(defun! copy-list (x)
	(if x
	  (if (not (consp x))
	    x
	    (cons (car x) (copy-list (cdr x))))
	  nil))

(defun! last (x)
	(if x
	  (if (consp x)
	    (if (cdr x)
	      (last (cdr x))
	      x))
	  nil))

;(defun! nth (x n)
;	(if (eq n 0)
;	  (car x)
;	  (nth (cdr x) (- n 1))))

(defun! repeat (n x fn)
	(if (<= n 1) x
	  (fn x (repeat (- n 1) x fn))))

(defun! pp (tree)
	(let*
	  (indent 1
	   insert-space (fn* (n) (repeat n " " str))
	   format-one-list (fn* (tr n)
				(str "("
				     (let* (loop (fn* (l)
						      (cond (not l) ")"
							    (consp (car l)) (str
									       (format-one-list (car l) (+ n indent))
									       "\n"
									       (insert-space n)
									       (loop (cdr l)))
						            t (str (car l)
								   (cond (not (cdr l)) ")"
									 t (str " " (loop (cdr l))))))))
				       (loop tr)))))
	  (println (format-one-list tree indent))))

(defm! concat (& body)
       (if (not body) nil
	 `(let* (concat_car (copy-list ,(car body)))
	   (do (if (consp concat_car)
		 (rplacd (last concat_car) (concat ,@(cdr body)))
		 (concat ,@(cdr body)))
	      concat_car))))

(defm! cond (& xs)
       (if (> (count xs) 0)
	 (list 'if (car xs)
	          (if (> (count xs) 1)
		    (nth xs 1)
		    (throw "odd number of forms to cond"))
		  (cons 'cond (cdr (cdr xs))))))

(defm! or (& xs)
       (if (not xs)
	 nil
	 (if (= 1 (count xs))
	   (car xs)
	   `(let* (or_FIXME ,(car xs))
	      (if or_FIXME or_FIXME
		(or ,@(cdr xs)))))))

