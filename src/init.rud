
(setq defun
	   (macro (name arg body)
		`(setq ,name (lambda ,arg ,body))))

(setq defmacro
	   (macro (name arg body)
		`(setq ,name (macro ,arg ,body))))

(defmacro resolv (x)
  `(setq ,x (resolv-bind ,x)))

(resolv resolv)
(resolv defun)
(resolv defmacro)

;; conditions
(defun not (a)
	(if a nil t))

(defmacro and (& xs)
    (if (not xs)
      t
      (if (= 1 (count xs))
        (car xs)
        (let* ((condvar (gensym)))
          `(let* ((,condvar ,(car xs)))
            (if ,condvar (and ,@(cdr xs)) ,condvar))))))

(defmacro or (& xs)
    (if (not xs)
      nil
      (if (= 1 (count xs))
        (car xs)
        (let* ((condvar (gensym)))
          `(let* ((,condvar ,(car xs)))
             (if ,condvar ,condvar (or ,@(cdr xs))))))))

(defmacro cond (& clauses)
    (if (> (count clauses) 0)
      (list 'if (car clauses)
            (if (> (count clauses) 1)
                (nth clauses 1)
                (err "cond requires an even number of forms"))
            (cons 'cond (cdr (cdr clauses))))))

;; list manipulation functions
(defun cadr (x) (car (cdr x)))
(defun cddr (x) (cdr (cdr x)))
(defun caddr (x) (car (cdr (cdr x))))

;(defun nth (x n)
;	(if (eq n 0)
;	  (car x)
;	  (nth (cdr x) (- n 1))))

(defun nthcdr (n x)
	(if n
	  (if (eq n 0)
	    (cdr x)
	    (nthcdr (- n 1) (cdr x)))
	  x))

(defun last (x)
	(if x
	  (if (seqp x)
	    (if (cdr x)
	      (last (cdr x))
	      x))
	  nil))

;(defun count (x)
;	(if x
;	  (if (consp x) (+ 1 (count (cdr x))))))

(defun count (x)
	(if x
	  (if (seqp x) (+ 1 (count (cdr x)))
	    0)
	  0))

;; list duplication functions

;(defun list (& body) body)
(defun list (& body) (copy-list body))

(defun copy-list (x n)
	(if (and n (= n 0)) nil
	   (if x
	     (if (seqp x)
	       (cons (car x) (copy-list (cdr x) (if n (- n 1))))
	       x))))

(defun remove (x lst)
	(if lst
	  (if (= x (car lst))
	    (remove x (cdr lst))
	    (cons (car lst) (remove x (cdr lst))))))

(defun concat (& body)
	(let* ((rec (lambda (x)
			(if (not x) nil
			  (if (consp x)
			    (let* ((copy (copy-list (car x))))
			      (if (consp copy)
				 (progn
				   (rplacd (last copy) (rec (cdr x)))
				   copy)
				 (rec (cdr x))))
			    x)))))
	  (rec body)))

;; map functions
(defun reduce (fn lst)
	(let*
	  ((rec      (lambda (head lst)
			 (if lst
			   (rec (fn head (car lst)) (cdr lst))
			   head))))
	  (if (cdr lst)	;; 2 or more arg
	      (rec (fn (car lst) (cadr lst)) (cddr lst))
	      (car lst))))	;; 1 element in lst

(defun mapcar (fn lst)
	(if lst
	  (cons (fn (car lst)) (mapcar fn (cdr lst)))))

(defun repeat (n x fn)
	(if (<= n 1) x
	  (fn x (repeat (- n 1) x fn))))




;; rudel-specific functions
(defun load-file (f)
	(eval (read-string (str "(progn " (slurp f) ")"))))

;(if (cond)
;    (true)
;    (false)
;(defun name (args)
;    (body))
;(let* (a b
;       c d)
;    (body))
;(progn
;    (body1)
;    (body2))
;(setq x
;    (value))
;(lambda name (args)
;    (body))

(defun insert-space (n)
	(repeat n " " str))

(defun pp-n (lst indent n)
	(let* ((prec  (copy-list lst (if (= n 0) nil n)))
	       (trail (if (= n 0) nil (nthcdr (- n 1) lst)))
	       (next  (+ indent 3)))
	  (str
	    "("
	    (reduce (lambda (x y) (str x " " y))
		    (mapcar (lambda (x) (pp x next)) prec))
	    (if trail
	      (str
	         "\n"
	         (insert-space next)
		 (reduce (lambda (x y) (str x "\n" (insert-space next) y))
			 (mapcar (lambda (x) (pp x next)) trail))
		 ")")
	      ")"))))

(defun pp (tree indent)
	(if (and (consp tree) (not (strp tree)))
	 (let*
	   ((trial (pp-n tree 0 0))
	    (len   (count trial)))
	   (if (> len 30)
	     (let* ((fn (car tree)))
	       (cond
		 (= fn 'if)       (pp-n tree indent 2)
		 (= fn 'setq)     (pp-n tree indent 2)
		 (= fn 'lambda)   (pp-n tree indent 2)
		 (= fn 'defun)    (pp-n tree indent 3)
		 (= fn 'defmacro) (pp-n tree indent 3)
		 t                (pp-n tree indent 1)))
	     trial))
	 (pr-str tree)))

(defun ppln (tree)
	(println (pp tree 0)))

;; debug functions
(defun trace (x)
	(setq *trace* (if x (cons x *trace*))))

(defun step ()
	(setq *debug* (cons '#step# *debug*)))

(defun cont ()
	(setq *debug* (remove '#step# *debug*)))

(defun break (x)
	(setq *debug* (cons x *debug*)))

(defun clear (x)
	(setq *debug* (remove x *debug*)))

(defun clear-all ()
	(setq *debug* nil))

;; resolv bindings
(resolv not)
(resolv and)
(resolv or)
(resolv cond)
(resolv cadr)
(resolv cddr)
(resolv caddr)
(resolv nthcdr)
(resolv count)
(resolv last)
(resolv list)
(resolv copy-list)
(resolv remove)
(resolv concat)
(resolv reduce)
(resolv mapcar)
(resolv repeat)
(resolv load-file)
(resolv insert-space)
(resolv pp-n)
(resolv pp)
(resolv ppln)

