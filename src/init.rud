
(defmacro! defun!
	   (fn* (name arg body)
		`(def! ,name (fn* ,arg ,body))))

(defmacro! defm!
	   (fn* (name arg body)
		`(defmacro! ,name (fn* ,arg ,body))))

;; conditions
(defun! not (a)
	(if a nil t))

(defm! or (& xs)
       (if (not xs)
	 nil
	 (if (= 1 (count xs))
	   (car xs)
	   `(let* (or_FIXME ,(car xs))
	      (if or_FIXME or_FIXME
		(or ,@(cdr xs)))))))

(defm! and (& xs)
       (if (not xs)
	 t
	 (if (= 1 (count xs))
	   (car xs)
	   `(let* (and_FIXME ,(car xs))
	      (if (not and_FIXME) and_FIXME
		(and ,@(cdr xs)))))))

(defm! cond (& xs)
       (if (> (count xs) 0)
	 (list 'if (car xs)
	          (if (> (count xs) 1)
		    (nth xs 1)
		    (throw "odd number of forms to cond"))
		  (cons 'cond (cdr (cdr xs))))))


;; list manipulation functions
(defun! cadr (x) (car (cdr x)))
(defun! cddr (x) (cdr (cdr x)))
(defun! caddr (x) (car (cdr (cdr x))))

;(defun! nth (x n)
;	(if (eq n 0)
;	  (car x)
;	  (nth (cdr x) (- n 1))))

(defun! nthcdr (n x)
	(if n
	  (if (eq n 0)
	    (cdr x)
	    (nthcdr (- n 1) (cdr x)))
	  x))

(defun! last (x)
	(if x
	  (if (seqp x)
	    (if (cdr x)
	      (last (cdr x))
	      x))
	  nil))

;(defun! count (x)
;	(if x
;	  (if (consp x) (+ 1 (count (cdr x))))))

(defun! count (x)
	(if x
	  (if (seqp x) (+ 1 (count (cdr x)))
	    0)
	  0))

;; list duplication functions

;(defun! list (& body) body)
(defun! list (& body) (copy-list body))

(defun! copy-list (x n)
	(if (and n (= n 0)) nil
	   (if x
	     (if (seqp x)
	       (cons (car x) (copy-list (cdr x) (if n (- n 1))))
	       x))))

(defun! remove (x lst)
	(if lst
	  (if (= x (car lst))
	    (remove x (cdr lst))
	    (cons (car lst) (remove x (cdr lst))))))

;(defm! concat (& body)
;       (if (not body) nil
;	 `(let* (concat_car (copy-list ,(car body)))
;	   (do (if (consp concat_car)
;		 (rplacd (last concat_car) (concat ,@(cdr body)))
;		 (concat ,@(cdr body)))
;	      concat_car))))
(defun! concat (& body)
	(let* (rec (fn* (x)
			(if (not x) nil
			  (if (consp x)
			    (let* (copy (copy-list (car x)))
			      (if (consp copy)
				 (do
				   (rplacd (last copy) (rec (cdr x)))
				   copy)
				 (rec (cdr x))))
			    x))))
	  (rec body)))

;; map functions
(defun! reduce (fn lst)
	(let*
	  (rec      (fn* (head lst)
			 (if lst
			   (rec (fn head (car lst)) (cdr lst))
			   head)))
	  (if (cdr lst)	;; 2 or more arg
	      (rec (fn (car lst) (cadr lst)) (cddr lst))
	      (car lst))))	;; 1 element in lst

(defun! mapcar (fn lst)
	(if lst
	  (cons (fn (car lst)) (mapcar fn (cdr lst)))))

(defun! repeat (n x fn)
	(if (<= n 1) x
	  (fn x (repeat (- n 1) x fn))))




;; rudel-specific functions
(defun! load-file (f)
	(eval (read-string (str "(do " (slurp f) ")"))))

;(if (cond)
;    (true)
;    (false)
;(defun! name (args)
;    (body))
;(let* (a b
;       c d)
;    (body))
;(do
;    (body1)
;    (body2))
;(def! x
;    (value))
;(fn* name (args)
;    (body))

(defun! insert-space (n)
	(repeat n " " str))

(defun! pp-n (lst indent n)
	(let* (prec  (copy-list lst (if (= n 0) nil n))
	       trail (if (= n 0) nil (nthcdr (- n 1) lst))
	       next  (+ indent 3))
	  (str
	    "("
	    (reduce (fn* (x y) (str x " " y))
		    (mapcar (fn* (x) (pp x next)) prec))
	    (if trail
	      (str
	         "\n"
	         (insert-space next)
		 (reduce (fn* (x y) (str x "\n" (insert-space next) y))
			 (mapcar (fn* (x) (pp x next)) trail))
		 ")")
	      ")"))))

(defun! pp (tree indent)
	(if (consp tree)
	 (let*
	   (trial (pp-n tree 0 0)
	    len   (count trial))
	   (if (> len 30)
	     (let* (fn (car tree))
	       (cond
		 (= fn 'if)      (pp-n tree indent 2)
		 (= fn 'def!)    (pp-n tree indent 2)
		 (= fn 'fn*)     (pp-n tree indent 2)
		 (= fn 'defun!)  (pp-n tree indent 3)
		 (= fn 'defm!)   (pp-n tree indent 3)
		 t               (pp-n tree indent 1)))
	     trial))
	 (pr-str tree)))

(defun! ppln (tree)
	(println (pp tree 0)))

;; debug functions
(defun! trace (x)
	(def! *trace* (if x (cons x *trace*))))

(defun! step ()
	(def! *debug* (cons '#step# *debug*)))

(defun! cont ()
	(def! *debug* (remove '#step# *debug*)))

(defun! break (x)
	(def! *debug* (cons x *debug*)))

(defun! clear (x)
	(def! *debug* (remove x *debug*)))

(defun! clear-all ()
	(def! *debug* nil))

