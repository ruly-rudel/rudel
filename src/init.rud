
(defmacro! defun!
	   (fn* (name arg body)
		`(def! ,name (fn* ,arg ,body))))

(defmacro! defm!
	   (fn* (name arg body)
		`(defmacro! ,name (fn* ,arg ,body))))

(defun! not (a)
	(if a nil t))

(defun! load-file (f)
	(eval (read-string (str "(do " (slurp f) ")"))))

;(defun! list (& body) body)
(defun! list (& body) (copy-list body))

;(defun! count (x)
;	(if x
;	  (if (consp x) (+ 1 (count (cdr x))))))

(defun! count (x)
	(if x
	  (if (seqp x) (+ 1 (count (cdr x)))
	    0)
	  0))

;(defun! copy-list (x)
;	(if x
;	  (if (not (consp x))
;	    x
;	    (cons (car x) (copy-list (cdr x))))
;	  nil))

(defun! copy-list (x n)
	(if (and n (= n 0)) nil
	   (if x
	     (if (seqp x)
	       (cons (car x) (copy-list (cdr x) (if n (- n 1))))
	       x))))

(defun! last (x)
	(if x
	  (if (seqp x)
	    (if (cdr x)
	      (last (cdr x))
	      x))
	  nil))

;(defun! nth (x n)
;	(if (eq n 0)
;	  (car x)
;	  (nth (cdr x) (- n 1))))

(defun! nthcdr (n x)
	(if n
	  (if (eq n 0)
	    (cdr x)
	    (nthcdr (- n 1) (cdr x)))
	  x))

(defun! repeat (n x fn)
	(if (<= n 1) x
	  (fn x (repeat (- n 1) x fn))))

;(defun! reduce (fn lst)
;	(let*
;	  (rec      (fn* (fn lst)
;			 (if (cdr lst)
;			   (fn (car lst) (rec fn (cdr lst)))
;			   (car lst))))
;	  (if lst		;; 1 or more arg
;	    (if (cdr arg)	;; 2 or more arg
;	      (rec fn lst)
;	      (fn (car lst) nil)))))
(defun! reduce (fn lst)
	(let*
	  (rec      (fn* (lst)
			 (if (cdr lst)
			   (fn (car lst) (rec (cdr lst)))
			   (car lst))))
	  (if lst		;; 1 or more arg
	      (rec lst))))

;(if (cond)
;    (true)
;    (false)
;(defun! name (args)
;    (body))
;(let* (a b
;       c d)
;    (body))
;(do
;    (body1)
;    (body2))
;(def! x
;    (value))
;(fn* name (args)
;    (body))

(defun! pp-item (lst indent)
	(if (eq 0 indent)
	  (str (pp (car lst) 0) (pp-item (cdr lst) indent))
	  )
	)

(defun! insert-space (n)
	(repeat n " " str))

(defun! pp-n (lst indent n)
	(let* (prec  (copy-list lst (if (= n 0) nil n))
	       trail (if (= n 0) nil (nthcdr (- n 1) lst))
	       next  (+ indent 3))
	  (str
	    (reduce (fn* (x y) (if y
				 (str
				   (pp x next) " " (pp y next))
				 (pp x next)))
		    prec)
	    (if trail
	      (str
	         "\n"
	         (insert-space next)
	         (reduce (fn* (x y) (if y
				 (str
				   (pp x next) "\n" (insert-space next) (pp y next))
				 (pp x next)))
		          trail)
		 ")")
	      ")"))))

(defun! pp (tree indent)
	(if (consp tree)
	 (let*
	   (trial (pp-n tree 0 0)
	    len   (count trial))
	   (if (> len 30)
	     (pp-n tree indent 1)
	     trial))
	 (str tree)))

;(defun! pp (tree)
;	(let*
;	  (indent 1
;	   insert-space (fn* (n) (repeat n " " str))
;	   format-one-list (fn* (tr n)
;				(str "("
;				     (let* (loop (fn* (l)
;						      (cond (not l) ")"
;							    (consp (car l)) (str
;									       (format-one-list (car l) (+ n indent))
;									       "\n"
;									       (insert-space n)
;									       (loop (cdr l)))
;						            t (str (car l)
;								   (cond (not (cdr l)) ")"
;									 t (str " " (loop (cdr l))))))))
;				       (loop tr)))))
;	  (println (format-one-list tree indent))))

;(defm! concat (& body)
;       (if (not body) nil
;	 `(let* (concat_car (copy-list ,(car body)))
;	   (do (if (consp concat_car)
;		 (rplacd (last concat_car) (concat ,@(cdr body)))
;		 (concat ,@(cdr body)))
;	      concat_car))))
(defun! concat (& body)
	(let* (rec (fn* (x)
			(if (not x) nil
			  (if (consp x)
			    (let* (copy (copy-list (car x)))
			      (if (consp copy)
				 (do
				   (rplacd (last copy) (rec (cdr x)))
				   copy)
				 (rec (cdr x))))
			    x))))
	  (rec body)))

(defm! cond (& xs)
       (if (> (count xs) 0)
	 (list 'if (car xs)
	          (if (> (count xs) 1)
		    (nth xs 1)
		    (throw "odd number of forms to cond"))
		  (cons 'cond (cdr (cdr xs))))))

(defm! or (& xs)
       (if (not xs)
	 nil
	 (if (= 1 (count xs))
	   (car xs)
	   `(let* (or_FIXME ,(car xs))
	      (if or_FIXME or_FIXME
		(or ,@(cdr xs)))))))

(defm! and (& xs)
       (if (not xs)
	 t
	 (if (= 1 (count xs))
	   (car xs)
	   `(let* (and_FIXME ,(car xs))
	      (if (not and_FIXME) and_FIXME
		(and ,@(cdr xs)))))))

