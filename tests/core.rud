(setq inc (fn* (a) (+ a 1)))

(setq dec (fn* (a) (- a 1)))

(setq zero? (fn* (n) (= 0 n)))

;(setq reduce
;  (fn* (f init xs)
;    (if (> (count xs) 0)
;      (reduce f (f init (car xs)) (cdr xs))
;      init)))

(setq identity (fn* (x) x))

(setq every?
  (fn* (pred xs)
    (if (> (count xs) 0)
      (if (pred (car xs))
        (every? pred (cdr xs))
        nil)
      t)))

(setq not (fn* (x) (if x nil t)))

(setq some
  (fn* (pred xs)
    (if (> (count xs) 0)
      (let* ((res (pred (car xs))))
        (if (pred (car xs))
          res
          (some pred (cdr xs))))
      nil)))

;(defmacro! and
;  (fn* (& xs)
;    (if (not xs)
;      t
;      (if (= 1 (count xs))
;        (car xs)
;        (let* (condvar (gensym))
;          `(let* (,condvar ,(car xs))
;            (if ,condvar (and ,@(cdr xs)) ,condvar)))))))

;(defmacro! or
;  (fn* (& xs)
;    (if (not xs)
;      nil
;      (if (= 1 (count xs))
;        (car xs)
;        (let* (condvar (gensym))
;          `(let* (,condvar ,(car xs))
;             (if ,condvar ,condvar (or ,@(cdr xs)))))))))

;(defmacro! cond
;  (fn* (& clauses)
;    (if (> (count clauses) 0)
;      (list 'if (car clauses)
;            (if (> (count clauses) 1)
;                (nth clauses 1)
;                (throw "cond requires an even number of forms"))
;            (cons 'cond (cdr (cdr clauses)))))))

(defmacro -> (x & xs)
    (if (not xs)
      x
      (let* ((form (car xs))
             (more (cdr xs)))
        (if (not more)
          (if (consp form)
            `(,(car form) ,x ,@(cdr form))
            (list form x))
          `(-> (-> ,x ,form) ,@more)))))

(defmacro ->> (x & xs)
    (if (not xs)
      x
      (let* ((form (car xs))
             (more (cdr xs)))
        (if (not more)
          (if (consp form)
            `(,(car form) ,@(cdr form) ,x)
            (list form x))
          `(->> (->> ,x ,form) ,@more)))))

nil
